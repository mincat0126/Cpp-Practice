# 관계 연산자
**관계 연산자**: 좌변가 우변을 비교하여 어느 값이 크고 작거나 같은지를 조사하는 연산자.  
> 피연산자를 2개 취하는 이항 연산자이다.  
> ==와 !=는 상등 연산자로 분류한다.(관계 연산자와 상등 연산자는 연산 순위가 다름)  
> 좌변과 우변의 데이터 타입은 같아야 한다.  
> 관계 연산자는 수식을 평가하여 참이면 1을 리턴하고 거짓이면 0을 리턴한다.  

|연산자|조건|
|----|----|
|==|좌변과 우변이 같다|
|!=|좌변과 우변이 다르다|
|>|좌변이 우변보다 크다|
|>=|좌변이 우변보다 크거나 같다|
|<|좌변이 우변보다 작다|
|<=|좌변이 우변보다 작거나 같다|

<pre>#include < stdio.h >
int main()
{
  int a,b;
  prtinf("2개의 정수를 입력하세요 :\n");
  scanf_s("%d,%d",&a,&a);
  if(a>b)
     {
        printf("1번째 정수가 2번째 정수보다 큽니다.\n");
     }
  else if(a<=b)
     {
        prtinf("1번째 정수가 2번째 정수보다 작거나 같습니다.\n");
     }
  else
     {
        printf("2개의 정수값이 같습니다.\n");
     }
}</pre><br><br><br>

# 논리 연산자
**논리 연산자**: 두 개 이상의 조건식을 결합하여 하나의 진리값을 만드는 연산자.  
> &&연산자와 ||연산자는 논리식을 피연산자로 가지는 이항 연산자이며 두 논리식의 값을 규칙에 따라 하나의 진리값을 만든다.  
> 논리 연산자를 사용하여 3가지 이상의 조건 연결이 가능하다.
> 괄호()를 사용하여 조건의 그룹을 묶을 수 있다.  
> 조건을 평가할 때 좌변으로 인해 결과값이 결정된다면 우변은 평가하지 않고 전체식을 리턴한다.(Short Circuit)  
> &&, || 이항 연산자는 교환 법칙이 성립하므로 좌우 조건식을 바꾸어도 결과는 동일하다.

|연산자|뜻|설명|
|----|----|----|
|!|논리 부정(Not)|논리식의 진위를 반대로 만든다|
|&&|논리곱(And)|두 논리식이 모두 참이어야 한다|
|\|\||논리합(Or)|두 논리식 중 하나만 참이면 참이다|

|좌변 논리식|우변 논리식|&& 연산자|Or 연사자|
|----|----|----|----|
|1|1|1|1|
|1|0|0|1|
|0|1|0|1|
|0|0|0|0|

<pre>#include < stdid.h >

int main()
{
	int a = 0, b = 6;

	if (a != 0 && b / a == 3)     //<실행결과>
	{                             //거짓
		printf("참\n");
	}
	else
	{
		printf("거짓\n");
	}
}</pre><br><br><br>

# 비트 연산자
**비트 연산자**: 두 개 이상의 피연산자의 비트를 연산하여 하나의 결과값을 리턴하는 연산자.  
&nbsp;&nbsp;&nbsp;**비트**: 기억 장치의 최소 단위. 1 또는 0 기억. 8개의 비트가 모여 1개의 바이트가 됨.  
> ~는 단항 연산자, 나머지는 2개의 피연산자를 취하는 이항 연산자이다.  
> 피연산자는 모두 정수형이거나 정수로 자동 변환 가능한 타입이어야 한다.(실수, 포인터 x)  
> 정수형이면 ^일때 1의 보수가 되면서 -값으로 변환된다.  
> <<연산자는 사실상 입력한 수만큼 곱하기를 하면 된다.(<<2는 곱하기 2)  
> 오른쪽 시프트 연산자는 사실상 입력한 수만큼 나누기를 하면 된다. 단 나머지는 버림한다.(>>3은 나누기 3)  

|연산자|뜻|
|----|----|
|~|비트를 반전|
|&|대응되는 비트가 모두 1일때 1|
|\||대응되는 비트중 하나 이상이 1이면 1|
|^|2개의 비트값이 다르면 1|
|<<|지정한 수만큼 왼쪽으로 비트들 이동|
|>>|지정한 수만큼 오른쪽으로 비트들 이동|

|b1|b2|b1 & b2|b1 or b2|b1 ^ b2|~b1|
|----|----|----|----|----|----|
|1|1|1|1|0|0|
|1|0|0|1|1|0|
|0|1|0|1|1|1|
|0|0|0|0|0|1|
<br>

<img width="249" height="66" alt="image" src="https://github.com/user-attachments/assets/222af8c3-1ae8-4b59-8ee5-ed318cdcacfe" />
<br><br><br>

> 특정 비트를 강제로 0으로 만드는 연산을 마스크 오프(mask off)라고 한다.  
<img width="249" height="96" alt="image" src="https://github.com/user-attachments/assets/11ba000c-bf60-4483-bb94-2808a2b6c5c0" />
<br><br><br>

> 특정 비트를 강제로 1로 만드는 연산을 마스크 온(mask on)이라고 한다.  
<img width="249" height="96" alt="image" src="https://github.com/user-attachments/assets/b1fc6100-ff25-449b-8fba-9e81c82eed77" />
<br><br><br>

<img width="249" height="96" alt="image" src="https://github.com/user-attachments/assets/c47c9219-8f72-4ca1-b139-e3890e3caa9f" />

<pre>#include < stdio.h >
  
  int main()
{
	int a = 15;                            //00001111
	int b = 21;                            //00010101
	                                       //<실행결과>
	printf("%d\n",a&b);                    //5
	printf("%d\n", a | b);                 //31
	printf("%d\n", ~a);                    //-16
	printf("%d\n", a ^ b);                 //26
	printf("%d\n", a <<2);                 //60
	printf("%d\n", a >>1);                 //7
}</pre><br><br><br>

## 쉬프트 연산자
**쉬프트 연산자**: 비트들을 지정한 수만큼 이동시키는 연사자.  
> 2개의 피연산자를 취하는 이항 연산자이다.     
> 피연산자에는 실수형이 작동을 하지 않는다.  
> 연산 속도가 매우 빠르다.
<br>

> 비트들을 이동할 때 이동할 공간이 없는 비트들을 밀려나 사라진다.   
<img width="249" height="96" alt="image" src="https://github.com/user-attachments/assets/12e15ca2-396a-4a26-8135-459332d7fb2a" />
<img width="249" height="89" alt="image" src="https://github.com/user-attachments/assets/87dbba39-2f78-49ed-b1a6-9665647b2ee4" />
<br><br><br>

> <<연산자는 사실상 입력한 수만큼 곱하기를 하면 된다.(<<2는 곱하기 4)  
> 오른쪽 시프트 연산자는 사실상 입력한 수만큼 나누기를 하면 된다. 단 나머지는 버림한다.(>>3은 나누기 8)  

<pre>
#include < stdio.h >
int main()
{
	int a = 5;
                                //<실행결과>
	printf("%d\n", a << 1);     //10
	printf("%d\n", a << 3);     //40
	printf("%d\n", a >> 1);     //2
	printf("%d\n", a >> 2);     //1
}
</pre>
