# 생성자
**생성자**: 클래스 스스로 자신을 초기화하는 방법을 정의하며 클래스를 기본 타입과 동등하게 만드는 언어적 장치     
&nbsp;&nbsp;&nbsp;**암시적인 방법**: 클래스이름 클래스변수(초기값인수,초기값인수,...){변수=초기값;...};  
&nbsp;&nbsp;&nbsp;**명시적인 방법**: 클래스이름 클래스변수=클래스이름(초기값인수,초기값인수,...){변수=초기값;...};  
> 생성자는 객체 초기화라는 한가지 일만 하며 컴파일러에 의해 호출되므로 이름이 고정적으로 정해져 있다.    
> 생성자의 이름은 항상 클래스의 이름과 동일하며 필요할 경우 초기화에 사용할 인수를 받아 들일 수는 있지만 리턴값은 가질 수 없다.  
> 생성자는 객체가 생성될 때 컴파일러에 의해 자동으로 호출된다.  
> 생성자도 오버로딩이 가능하며 디폴트 인수를 사용할 수도 있고 인라인으로 선언할 수도 있다.  
> 컴파일러는 객체 선언문의 인수 목록을 보고 호출할 생성자를 결정하는데 만약 해당되는 생성자가 없을 경우는 에러로 처리된다.  

<pre>
#include "Turboc.h"
using namespace std;

class Position
{
private:
    int x;
    int y;
    char ch;

public:
    Position(int ax, int ay, char ach)//생성자
    {
        x = ax;
        y = ay;
        ch = ach;
    }

    void OutPosition()
    {
        gotoxy(x, y);
        putchar(ch);
    }
};

void main()
{
    Position Here(30, 10, 'A');
    Here.OutPosition();
}
</pre>
<pre>
#include "Turboc.h"

class Position
{
private:
     int x;
     int y;
     char ch;
 
public:
     Position(char ach) {
          x=random(80);
          y=random(24);
          ch=ach;
     }
  
     Position(int ax, int ay, char ach='S') {
          x=ax;
          y=ay;
          ch=ach;
     }
  
     void OutPosition() {
          gotoxy(x, y);
          putchar(ch);
     }
};

void main()
{
     randomize();
     Position Here(30,10,'A');
     Position There(40,5);
     Position Where('K');

     Here.OutPosition();
     There.OutPosition();
     Where.OutPosition();
}
</pre><br><br><br><br><br>

# 파괴자
**파괴자**: 뒷처리를 하는 특별한 멤버 함수   
&nbsp;&nbsp;&nbsp;**선언**: ~클래스이름(){동작}  
> 객체가 소멸될 때 컴파일러에 의해 자동으로 호출된다.  
> 파괴자의 이름은 클래스 이름앞에 ~를(tilde라고 읽는다) 붙인 것으로 고정되어 있으며 인수와 리턴값은 가지지 않는다.

**<생성자,파괴자 특징>**
1. 이름들이 정해져 있다.
2. 리턴값이 없다.
3. 반드시 public 액세스 속성을 가져야 한다.
4. 생성자는 인수가 있지만 파괴자는 인수가 없다.
5. friend, static이 될 수 없다.
6. 파괴자는 가상 함수로 정의될 수 있지만 생성자는 안된다.
7. 디폴트가 있다.

<pre>
#include "Turboc.h"

class Person
{
private:
     char *Name;
     int Age;

public:
     Person(const char *aName, int aAge) {
          Name=new char[strlen(aName)+1];
          strcpy(Name,aName);
          Age=aAge;
     }
    
     ~Person() {
          delete [] Name;
     }

     void OutPerson() {
          printf("이름 : %s 나이 : %d\n",Name,Age);
     }
};

void main()
{
     Person Boy("을지문덕",25);
     Boy.OutPerson();
}
</pre><br><br><br><br><br>

# new
**new**: 실행중에 객체를 동적으로 생성하는 연산자   
> 객체를 위한 메모리를 할당한 후 생성자를 호출하므로 동적 할당문에 생성자가 요구하는 인수를 전달해야 한다.  

**delete**: 객체를 메모리에서 해제하는 연산자.
> 파괴자는 생성자가 할당해 놓은 메모리를 해제하며 delete 연산자는 객체 그 자체를 메모리에서 해제한다.  
> 객체 그 자체도 힙에 생성되지만 객체가 사용하는 메모리도 힙에 생성된다.  
> 동적 할당의 대상이 객체일 때는 반드시 생성자를 호출하는 new 연산자를 사용해야 한다.  

<pre>
void main()
{
     Person Boy("을지문덕",25);
     Boy.OutPerson();

    Person *pGirl;
    pGirl=new Person("신사임당",19);
    pGirl->OutPerson();
    delete pGirl;
}
</pre>
