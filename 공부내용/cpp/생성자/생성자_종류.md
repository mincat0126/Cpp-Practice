# 디폴트 생성자 
**디폴트 생성자**: 인수를 가지지 않는 생성자   
> 생성자는 오버로딩이 가능하므로 여러 개를 둘 수 있는데 그 중 인수가 없는 생성자를 디폴트 생성자라고 부른다.    
> 만약 클래스에 생성자를 정의하지 않으면 컴파일러가 자동으로 디폴트 함수로 빈 함수를 만든다.  
> 컴파일러가 디폴트 생성자를 만드는 경우는 클래스가 생성자를 전혀 정의하지 않을 때 뿐이다.  
> 생성자가 인수를 가지고 있더라도 디폴트 인수 기능에 의해 디폴트 생성자가 되는 경우도 있다.  
> 디폴트 생성자가 없는 클래스는 객체 배열을 선언할 수 없다.  

<pre>
#include "Turboc.h"

class Position
{
private:
    int x;
    int y;
    char ch;

public:
    Position()
    {
        x = 0;
        y = 0;
        ch = ' ';
    }

    void OutPosition()
    {
        if (ch != ' ')
        {
            gotoxy(x, y);
            putch(ch);
        }
    }
};

void main()
{
    Position Here;
    Here.OutPosition();
}
</pre><br><br><br><br><br>

# 복사 생성자
**복사 생성자**: 자신과 같은 타입의 다른 객체에 대한 레퍼런스를 전달받아 이 레퍼런스로부터 자신을 초기화 하는 생성자   
> 복사 생성자의 임무는 새로 생성되는 객체가 원본과 똑같으면서 완전한 독립성을 가지도록 하는 것이다.  
> 함수의 인수로 사용되거나 리턴값으로 사용되는 객체는 반드시 복사 생성자를 제대로 정의해야 한다.  
> 복사 생성자의 인수는 반드시 객체의 레퍼런스여야 하며 객체를 인수로 취할 수는 없다.  
> 복사 생성자로 전달되는 인수는 상수일 수도 있고 아닐 수도 있다.  
> 클래스가 복사 생성자를 정의하지 않으면 컴파일러가 디폴트 복사 생성자를 만든다.  
> 컴파일러가 만드는 디폴트 복사 생성자는 멤버끼리 1:1로 복사함으로써 원본과 완전히 같은 사본을 만들기만 할 뿐 깊은 복사를 하지는 않는다.  

<pre>
#include "Turboc.h"

class Person
{
private:
    char* Name;
    int Age;

public:
    Person(const char* aName, int aAge)
    {
        Name = new char[strlen(aName) + 1];
        strcpy(Name, aName);
        Age = aAge;
    }

    Person(const Person& Other)
    {

        Name = new char[strlen(Other.Name) + 1];
        strcpy(Name, Other.Name);
        Age = Other.Age;
    }

    ~Person()
    {
        delete[] Name;
    }

    void OutPerson()
    {
        printf("이름 : %s 나이 : %d\n", Name, Age);
    }

};

void main()
{
    Person Boy("강감찬", 22);
    Person Young = Boy;
    Young.OutPerson();
}
</pre><br><br><br><br><br>

# 초기화 리스트
**초기화 리스트**: 함수 선두와 본체 사이에 :을 찍고 멤버와 초기값의 대응 관계를 나열하는 것    
&nbsp;&nbsp;&nbsp;**선언**: 생성자(인수, 인수,...):변수(인수),변수(인수),...{동작}    
> 초기화 리스트의 항목은 "멤버(인수)"의 형태를 띠며 멤버=인수 대입 동작을 한다.  
> 단순한 대입만 가능하며 복잡한 계산을 한다거나 함수를 호출하는 것은 불가능하다.  
> 상수 클래스의 멤버일 때는 객체가 만들어질 때까지 초기화를 연기할 수 있으며 생성자의 초기화 리스트에서만 초기화 가능하다.  
> 초기화 리스트는 본체 이전의 특별한 영역이며 생성자에서만 이 문법이 적용된다.  
> 상수는 객체가 생성될 때 반드시 초기화되어야 하며 상수 멤버 초기화의 책임은 생성자에게 있다.  
> 레퍼런스 멤버를 가지는 클래스는 생성자에서 이 멤버를 초기화해야 한다.  
> 클래스도 다른 클래스의 객체를 멤버로 가질 수 있다.  

<pre>
#include <iostream>

class Some
{
public:
    const int Value;

    Some(int i) : Value(i) {}

    void OutValue() { printf("%d\n", Value); }
};

void main()
{
    Some S(5);
    S.OutValue();
}
</pre>
<pre>
#include <iostream>

class Some
{
public:
    int& ri;

    Some(int& i) : ri(i) {}

    void OutValue() { printf("%d\n", ri); }
};

void main()
{
    int i = 5;
    Some S(i);
    S.OutValue();
}
</pre>
<pre>
#include <iostream>

class Position
{
public:
    int x, y;
    Position(int ax, int ay) { x = ax; y = ay; }
};

class Some
{
public:
    Position Pos;

    Some(int x, int y) : Pos(x, y) {}

    void OutValue() { printf("%d,%d\n", Pos.x, Pos.y); }
};

void main()
{
    Some S(3, 4);
    S.OutValue();
}
</pre>
