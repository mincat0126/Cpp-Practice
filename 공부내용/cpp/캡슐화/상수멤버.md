# 상수 멤버
**상수 멤버**: 한 번 값이 정해지면 변경될 수 없는 멤버  
> 상수는 대입을 받을 수 없기 때문에 반드시 생성자의 초기화 리스트에서 초기화해야 한다.   
> 상수 멤버가 모든 객체에 대해 항상 같은 값을 가진다면 정적 멤버로 선언한 후 딱 한 번만 초기화할 수도 있다.    
> 정적 멤버는 클래스 외부에서 다시 정의해야 하며 일반 정적 멤버와는 달리 상수 멤버는 선언할 때 초기값을 반드시 지정해야 한다.   
> 사용하고자 하는 상수가 정수 타입인 경우는 상수 멤버 대신 열거 멤버를 사용할 수도 있다.

**상수 멤버 함수**: 멤버값을 변경할 수 없는 함수  
&nbsp;&nbsp;&nbsp;**선언**: 리턴타입 함수명() const{};  
> 상수로 선언된 객체에 대해서는 상수 멤버 함수만 호출할 수 있으며 비상수 멤버 함수는 호출할 수 없다.  
> 상수 멤버 함수라도 정적 멤버 변수의 값은 변경할 수 있다.  
> 비상수 멤버 함수가 받는 객체 포인터 this는 Position * const 형이며 this 자체는 상수이지만 this가 가리키는 대상은 상수가 아니다.  
> 상수 멤버 함수가 받는 객체 포인터 this는 const Position * const 형이며 this도 상수이고 this가 가리키는 대상도 상수이다. 

<pre>
#include < iostream >

class MathCalc
{
private:
    const double pie;

public:
    MathCalc(double apie) : pie(apie) {}
    void DoCalc(double r)
    {
        printf("반지름 %.2f인 원의 둘레 = %.2f\n", r, r * 2 * pie);
    }
};

void main()
{
    MathCalc M(3.1416);
    M.DoCalc(5);
}
</pre>

<pre>
#include < iostream >

class MathCalc
{
private:
    static const double pie;

public:
    MathCalc() {}
    void DoCalc(double r)
    {
        printf("반지름 %.2f인 원의 둘레 = %.2f\n", r, r * 2 * pie);
    }
};
const double MathCalc::pie = 3.1416;

void main()
{
    MathCalc M;
    M.DoCalc(5);
}
</pre><br><br><br><br><br>

# mutable
**mutable**: mutable로 지정된 멤버는 상수 함수나 상수 객체에 대해서도 값을 변경할 수 있다.  
mutable은 상수 멤버 함수나 상수 객체의 상수성을 완전히 무시해 버린다.

<pre>
#include < iostream >

class Some
{
private:
    mutable int v;

public:
    Some() {}
    void func() const { v = 0; }
};

void main()
{
    Some S;
    S.func();

    const Some T;
    T.func();
}
</pre>
