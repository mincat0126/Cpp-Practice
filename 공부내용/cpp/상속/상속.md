# 상속
**상속**: 이미 정의되어 있는 클래스의 모든 특성을 물려 받아 새로운 클래스를 작성하는 기법   
&nbsp;&nbsp;&nbsp;**형태**: class 파생클래스: 상속액세스_지정자 기반클래스 

**protected**: protected로 지정된 멤버는 클래스 외부에서는 참조할 수 없지만 파생 클래스에서는 참조할 수 있는 액세스 속성   

**<상속의 목적>**
1. 기존의 클래스 재활용
2. 공통되는 부분을 상위 클래스에 통합하여 반복을 제거하고 유지, 보수를 편리하게 한다.
3. 공동의 조상을 가지는 계층을 만듬으로써 객체의 집합에 다형성을 부여

|액세스 지정자|클래스 외부|파생 클래스|설명|
|----|----|----|----|
|private|액세스 X|액세스 X|무조건 금지|
|protected|액세스 X|액세스 O|파생 클래스만 허용|
|public|액세스 O|액세스 O|무조건 허용|

<br><br><br>
**상속액세스 지정자**: 기반 클래스의 멤버들이 파생 클래스로 상속될 때 액세스 속성이 어떻게 변할 것인가를 지정   
> 상속 액세스 지정자가 생략되면 디폴트인 private가 적용된다.

|상속 액세스 지정자|기반 클래스의 액세스 속성=파생 클래스의 액세스 속성|
|----|----|
|public|public=public / private=액세스 불가능 / protected=protected|
|private|public=private / private=액세스 불가능 / protected=private|
|protected|public=protected / private=액세스 불가능 / protected=protected|

<pre>
#include "Turboc.h"

class Coord
{
protected:
    int x, y;

public:
    Coord(int ax, int ay) { x = ax; y = ay; }
    void GetXY(int& rx, int& ry) const { rx = x; ry = y; }
    void SetXY(int ax, int ay) { x = ax; y = ay; }
};

class Point : public Coord
{
protected:
    char ch;

public:
    Point(int ax, int ay, char ach) : Coord(ax, ay) { ch = ach; }
    void Show()
    {
        gotoxy(x, y); putch(ch);
    }

    void Hide()
    {
        gotoxy(x, y); putch(' ');
    }
};

void main()
{
    Point P(10, 10, '@');
    P.Show();
}
</pre>
