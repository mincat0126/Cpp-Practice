# 상속
**상속**: 이미 정의되어 있는 클래스의 모든 특성을 물려 받아 새로운 클래스를 작성하는 기법   
&nbsp;&nbsp;&nbsp;**형태**: class 파생클래스: 상속액세스_지정자 기반클래스   
> 부모와 자식 클래스의 관계를 IS A 관계라고 하는데 이는 자식 클래스가 일종의 부모 클래스라는 뜻이다.  
> 다중상속에서 파생되는 클래스는 기반 클래스들의 모든 속성을 물려받는다.  
> 클래스간의 관계 일람표를 클래스 계층도라고 한다.  
> 상속받은 멤버는 파생 클래스에서 직접 초기화할 수 없으며 기반 클래스에게 초기화를 부탁해야 한다.  
> 파생 클래스가 기반 클래스의 생성자를 호출할 때는 초기화 리스트를 사용해야 한다.  
> 만약 기반 클래스에 여러 개의 생성자가 오버로딩되어 있다면 초기화 리스트의 인수 목록에 따라 호출될 생성자가 결정된다.  
> 파생 클래스의 객체가 파괴될 때는 생성자가 호출된 역순으로 파괴자가 호출된다.  
> 생성자,파괴자,대입 연산자,정적 멤버 변수 및 함수,프렌드 관계 지정은 상속되지 않는다.  
> 원하는 멤버만 선택적으로 상속한다거나 특정 멤버를 상속받지 않는 방법은 없다.  
> 상속받은 멤버와 새로 정의한 멤버의 이름이 중복될 경우 자신의 멤버가 우선적으로 참조된다.  
> 중복 멤버의 이름에서 부모의 멤버를 참조하고 싶다면 멤버 이름앞에 범위 연산자와 부모 클래스의 이름을 적는다.

**protected**: protected로 지정된 멤버는 클래스 외부에서는 참조할 수 없지만 파생 클래스에서는 참조할 수 있는 액세스 속성   

**<상속의 목적>**
1. 기존의 클래스 재활용
2. 공통되는 부분을 상위 클래스에 통합하여 반복을 제거하고 유지, 보수를 편리하게 한다.
3. 공동의 조상을 가지는 계층을 만듬으로써 객체의 집합에 다형성을 부여

**<상속의 특성>**
1. 하나의 기반 클래스로부터 여러 개의 클래스를 파생시킬 수 있다.
2. 파생된 클래스로부터 새로운 클래스를 얼마든지 파생시킬 수 있다.
3. C++은 두 개 이상의 클래스로부터 새로운 클래스를 파생시킬 수 있는데 이를 다중 상속이라고 한다.

|액세스 지정자|클래스 외부|파생 클래스|설명|
|----|----|----|----|
|private|액세스 X|액세스 X|무조건 금지|
|protected|액세스 X|액세스 O|파생 클래스만 허용|
|public|액세스 O|액세스 O|무조건 허용|

<br><br><br>
**상속액세스 지정자**: 기반 클래스의 멤버들이 파생 클래스로 상속될 때 액세스 속성이 어떻게 변할 것인가를 지정   
> 상속 액세스 지정자가 생략되면 디폴트인 private가 적용된다.

|상속 액세스 지정자|기반 클래스의 액세스 속성=파생 클래스의 액세스 속성|
|----|----|
|public|public=public / private=액세스 불가능 / protected=protected|
|private|public=private / private=액세스 불가능 / protected=private|
|protected|public=protected / private=액세스 불가능 / protected=protected|

<pre>
#include "Turboc.h"

class Coord
{
protected:
    int x, y;

public:
    Coord(int ax, int ay) { x = ax; y = ay; }
    void GetXY(int& rx, int& ry) const { rx = x; ry = y; }
    void SetXY(int ax, int ay) { x = ax; y = ay; }
};

class Point : public Coord
{
protected:
    char ch;

public:
    Point(int ax, int ay, char ach) : Coord(ax, ay) { ch = ach; }
    void Show()
    {
        gotoxy(x, y); putch(ch);
    }

    void Hide()
    {
        gotoxy(x, y); putch(' ');
    }
};

void main()
{
    Point P(10, 10, '@');
    P.Show();
}
</pre>

<pre>
#include "Turboc.h"
#include < math.h >

class Coord
{
protected:
      int x,y;

public:
      Coord(int ax, int ay) { x=ax;y=ay; }
      void GetXY(int &rx, int &ry) const { rx=x;ry=y; }
      void SetXY(int ax, int ay) { x=ax;y=ay; }
};

class Point : public Coord
{
protected:
      char ch;

public:
      Point(int ax, int ay, char ach) : Coord(ax,ay) { ch=ach; }
      void Show() {
             gotoxy(x,y);putch(ch);
      }

      void Hide() {
             gotoxy(x,y);putch(' ');
      }
};

class Circle : public Point
{
protected:
     int Rad;

public:
     Circle(int ax, int ay, char ach, int aRad) : Point(ax,ay,ach) { Rad=aRad; }
     void Show() {
          for (double a=0;a<360;a+=15) {
              gotoxy(int(x+sin(a*3.14/180)*Rad),int(y-cos(a*3.14/180)*Rad));
              putch(ch);
          }
     }

     void Hide() {
          for (double a=0;a<360;a+=15) {
              gotoxy(int(x+sin(a*3.14/180)*Rad),int(y-cos(a*3.14/180)*Rad));
              putch(' ');
          }
     }
};

void main()
{
     Point P(10,10,'@');
     P.Show();
     Circle C(40,10,'*',8);
     C.Show();
}
</pre>
