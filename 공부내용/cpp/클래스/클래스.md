# 클래스
**클래스**: 구조체에 함수를 추가한 형태   
&nbsp;&nbsp;&nbsp;**선언**: class 이름{액세스:변수;함수;...};    
> 구조체의 디폴트 액세스 지정은 public이고 클래스의 디폴트 액세스 지정은 private이다.  
> 구조체가 하나의 타입으로 인정되는 것과 마찬가지로 클래스도 하나의 타입으로 취급된다.   
> 클래스의 이름은 int, double, char 같은 기본형 타입과 동등한 자격을 가지며 사용 방법도 똑같다.  
> 객체들을 먼저 만들고 객체들을 조립하여 프로그램을 완성하므로 상향식 개발이라고 한다  

|정수형|Complex 클래스|C++의 관련 문법|
|----|----|----|
|int i;|Complex C;|클래스의 이름이 타입과 같은 자격을 가진다|
|int i=3;|Complex C(1.0, 2.0);|생성자, 선언과 동시에 초기화할 수 있다|
|int i=j;|Complex D=C;|복사 생성자. 같은 타입의 다른 객체로부터 생성된다|
|i=j;|D=C;|대입 연산자|
|i+j;|D+C;|연산자 오버로딩|
|i=3.14|Complex C(1.2);|변환 생성자, 변환 함수|
|3+i|1.0+C;|전역 연산자 함수와 프렌드|

<pre>
#include "Turboc.h"

class Position
{
private:
    int x;
    int y;
    char ch;

public:
    void InitRand()
    {
        x = random(80);
        y = random(24);
        ch = random('Z' - 'A' + 1) + 'A';
    }

    void OutPosition()
    {
        gotoxy(x, y);
        putchar(ch);
    }

    void ErasePosition()
    {
        gotoxy(x, y);
        putchar(' ');
    }
};

void main()
{
    Position arPos[50];
    Position* pPos;
    int i;
    randomize();

    for (i = 0; i < sizeof(arPos) / sizeof(arPos[0]); i++)
    {
        arPos[i].InitRand();
        arPos[i].OutPosition();
        delay(50);
    }

    delay(1000);
    pPos = arPos;

    for (i = 0; i < sizeof(arPos) / sizeof(arPos[0]); i++)
    {
        pPos->ErasePosition();
        pPos++;
        delay(50);
    }
}
</pre><br><br><br><br><br>

# 인스턴스
**인스턴스**: 선언문에 의해 생성된 클래스형의 변수  
&nbsp;&nbsp;&nbsp;**선언**: 클래스명 인스턴스이름;  
> 클래스가 표현하는 정보를 실제로 기억하고 관리하는 주체가 바로 인스턴스이며 프로그래밍 대상은 클래스가 아니라 인스턴스이다.   
> 한 글래스에 대해 여러 개의 인스턴스를 동시에 생성할 수 있다.  
> 인스턴스의 실제 크기는 클래스에 선언된 모든 멤버 변수의 총 크기와 일치한다.  
> 독립된 정보 저장을 위해 멤버 변수는 각 인스턴스들이 따로 가지지만 멤버 함수는 클래스에 속한 모든 인스턴스들이 공유한다.  

**오브젝트**: 프로그램을 구성하는 독립적인 부품 
