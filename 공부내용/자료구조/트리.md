# 트리
**트리**: 부모-자식 개념을 가지는 비순환적 경로로 연결되어있는 자료구조  
**노드**: 트리를 구성하는 기본 원소(A,B,C,D,E,F,G,H,I,J)  
**루트**: 부모가 없는 최상위 노드(A)  
**부모**: 어떤 노드의 윗 노드(B는 D,E의 부모 노드)  
**자식**: 어떤 노드의 자식 노드(F는 C의 자식 노드)  
**형제**: 같은 부모를 가진 노드(F와 G)  
**링크**: 노드를 연결하는 것   
**레벨**: 루트에서의 거리(A가 1일경우 B는2 D는3)  
**높이**: 트리의 최대 레벨 즉 맨 아래에 있는 노드(A가 1일경우 높이4)  
**차수**: 자식 노드의 개수(D는 2)  
**잎 노드**: 자식이 없는 맨 마지막 노드(H,I,J)  
**내부 노드**: 잎 노드가 아닌 노드(A,B,C,D,E,F,G)  
**순서 트리**: 노드의 자식들 사이에 순서가 있는 트리  
**비순서 트리**: 노드의 자식들 사이에 순서가 없는 트리  
**서브 트리**: 트리를 구성하는 작은 트리(A는 B와C의 서브트리)  
**포레스트**: 트리 여러 개가 모인 것  
> 트리는 실제 데이터를 가지는 노드와 노드를 연결하는 링크로 구성된다.  
> 링크라는 용어 대신 버텍스, 에지라는 용어를 사용하기도 한다.  
> 잎 노드를 외부 노드라고도 부른다.
> 트리로 어떤 작업을 하려면 트리의 모든 노드를 한 번씩 방문하는 순회를 해야 한다.

**<트리 주의사항>**
1. 모든 트리는 단 하나의 유일한 루트를 가지며 루트 아래로 무수히 많은 노드들이 있다.
2. 트리의 노드들은 항상 루트로 향하는 링크를 하나씩 가지되 루트는 링크를 가지지 않으므로 링크의 개수는 항상 노드보다 하나 더 작다
3. 루트의 레벨은 0또는 1로한다.

<img width="1280" height="679" alt="image" src="https://github.com/user-attachments/assets/0704f10b-316b-4652-aca0-b1038ffea051" />

<pre>#include < stdio.h >
#include < windows.h >

struct Node
{
    int data;
    Node* left;
    Node* right;
};
Node* Root;

Node** Queue;
int QSize;
int head, tail;

void InitQueue(int size)
{
    QSize = size;
    Queue = (Node**)malloc(QSize * sizeof(Node*));
    head = tail = 0;
}

void FreeQueue()
{
    free(Queue);
}

BOOL Insert(Node* data)
{
    if ((tail + 1) % QSize == head)
    {
        return FALSE;
    }
    Queue[tail] = data;
    tail = (tail + 1) % QSize;

    return TRUE;
}

Node* Delete()
{
    Node* data;

    if (head == tail)
    {
        return NULL;
    }

    data = Queue[head];
    head = (head + 1) % QSize;

    return data;
}

void InitTree(int data)
{
    Root = (Node*)malloc(sizeof(Node));
    Root->data = data;
}

Node* AddChild(Node* Parent, int data, BOOL bLeft)
{
    Node* New;

    New = (Node*)malloc(sizeof(Node));
    New->data = data;
    New->left = NULL;
    New->right = NULL;

    if (bLeft)
    {
        Parent->left = New;
    }
    else
    {
        Parent->right = New;
    }
    return New;
}

void FreeTree(Node* R)
{
    if (R->left) FreeTree(R->left);
    if (R->right) FreeTree(R->right);
    free(R);
}

void LevelOrder(Node* R)
{
    Node* tNode;
    Insert(R);

    while (head != tail)
    {
        tNode = Delete();
        printf("%d ", tNode->data);

        if (tNode->left) Insert(tNode->left);
        if (tNode->right) Insert(tNode->right);
    }
}

void main()
{
    Node* Left, * Right;

    InitQueue(128);
    InitTree(1);

    Left = AddChild(Root, 2, TRUE);
    Right = AddChild(Root, 3, FALSE);

    AddChild(Left, 4, TRUE);
    AddChild(Left, 5, FALSE);
    AddChild(Right, 6, TRUE);

    LevelOrder(Root); puts("");

    FreeTree(Root);
    FreeQueue();
}</pre>
