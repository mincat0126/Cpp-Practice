# 단순 연결 리스트
**연결 리스트**: 요소들이 메모리 도처에 흩어져서 존재하지만 링크에 의해 논리적으로 연결되어 있어 링크로 요소들을 찾을 수 있는 자료 구죠  
**링크**: 자기 다음의 요소가 누구인지를 기억하고 연결 정보를 저장하는 것  
**머리**: 시작점을 기억하는 노드  
> 동적 배열과 연결 리스트는 완전히 같은 용도의 자료 구죠로 서로 대체가 가능하지만 구성 원리나 관리 방법 등이 다르다.    
> 배열 요소 하나는 자신이 기억할 데이터값만 가지지만, 연결 리스트 요소인 노드는 데이터외에 연결 상태에 대한 정보인 링크를 추가로 가져야 한다.  
> 링크를 하나만 가지는걸 단순 연결 리스트, 두 개의 링크를 가지는걸 이중 연결 리스트라고 한다.  
> 노드를 구성하는 데이터와 링크는 타입이 다르기 때문에 노드는 이형 타입의 집합인 구조체로 정의된다.  
> 어떤 노드가 연결 리스트의 첫 번째 노드인지는 따로 정해야 한다.  
<img width="476" height="137" alt="image" src="https://github.com/user-attachments/assets/59fab78d-7f97-41d7-88c6-413c692a33b6" />
<img width="444" height="96" alt="image" src="https://github.com/user-attachments/assets/804bcdb5-4617-4c22-beb5-6db165d4f51c" />

<pre>struct Node
{
     int value;            // 데이터
     Node *next;           // 링크
};</pre>  

<pre>#include < stdio.h >
#include < windows.h >

// 노드 구조체
struct Node
{
    int value;
    Node* next;
};
Node* head;

// 연결 리스트 초기화 - 머리를 할당한다.
void InitList()
{
    head = (Node*)malloc(sizeof(Node));
    head->next = NULL;
}

// Target 다음에 노드를 삽입한다.
Node* InsertNode(Node* Target, Node* aNode)
{
    Node* New;
    New = (Node*)malloc(sizeof(Node));

    *New = *aNode;
    New->next = Target->next;
    Target->next = New;

    return New;
}

// Target 다음 노드를 삭제한다.
BOOL DeleteNode(Node* Target)
{
    Node* Del;
    Del = Target->next;

    if (Del == NULL)
    {
        return FALSE;
    }

    Target->next = Del->next;
    free(Del);

    return TRUE;
}

// 연결 리스트의 모든 노드와 머리를 해제한다.
void UnInitList()
{
    while (DeleteNode(head)) { ; }

    free(head);
    head = NULL;
}

void main()
{
    int i;
    Node* Now, Temp;

    InitList();

    // 다섯 개의 노드 삽입
    Now = head;
    for (i = 1; i <= 5; i++)
    {
        Temp.value = i;
        Now = InsertNode(Now, &Temp);
    }

    // 두 번째 노드 삭제
    DeleteNode(head->next);

    // 순회하면서 출력
    for (Now = head->next; Now; Now = Now->next)
    {
        printf("%d\t", Now->value);
    }

    printf("\n");

    UnInitList();
}</pre><br><br><br><br><br>

# 이중 연결 리스트
**이중 연결 리스트**: 전후의 노드에 대한 링크를 각각 따로 가지는 리스트

<pre>struct Node
{
     int value;
     Node *prev;
     Node *next;
};</pre>

<pre>#include < stdio.h >
#include < windows.h >

struct Node
{
    int value;
    Node* prev;
    Node* next;
};
Node* head;

// 연결 리스트 초기화
void InitList()
{
    head = (Node*)malloc(sizeof(Node));
    head->prev = NULL;
    head->next = NULL;
}

// 지정한 노드의 오른쪽에 삽입
Node* InsertNodeRight(Node* Target, Node* aNode)
{
    Node* New;
    Node* Right;

    New = (Node*)malloc(sizeof(Node));
    *New = *aNode;

    Right = Target->next;
    New->next = Right;
    New->prev = Target;
    Target->next = New;

    if (Right)
    {
        Right->prev = New;
    }
    return New;
}

// 지정한 노드의 왼쪽에 삽입
Node* InsertNodeLeft(Node* Target, Node* aNode)
{
    Node* Left;
    Left = Target->prev;

    if (Left)
    {
        return InsertNodeRight(Left, aNode);
    }

    return NULL;
}

// 제일 끝에 노드를 추가
void AppendNode(Node* aNode)
{
    Node* tail;

    for (tail = head; tail->next; tail = tail->next) { ; }
    InsertNodeRight(tail, aNode);
}

BOOL DeleteNode(Node* Target)
{
    Node* Left, * Right;

    if (Target == NULL || Target == head)
    {
        return FALSE;
    }

    Left = Target->prev;
    Right = Target->next;

    Left->next = Right;

    if (Right)
    {
        Right->prev = Left;
    }
    free(Target);

    return TRUE;
}

// idx번째 노드를 찾는다.
Node* FindNodeByIndex(int idx)
{
    Node* Now;
    int Index = 0;

    for (Now = head->next; Now; Now = Now->next)
    {
        if (Index == idx)
        {
            return Now;
        }
        Index++;
    }
    return NULL;
}

// 노드의 순서값을 구한다.
int GetNodeIndex(Node* Target)
{
    Node* Now;
    int Index = 0;

    for (Now = head->next; Now; Now = Now->next)
    {
        if (Now == Target)
        {
            return Index;
        }
        Index++;
    }
    return -1;
}

// 노드의 개수를 조사
int GetListCount()
{
    Node* Now;
    int Count = 0;

    for (Now = head->next; Now; Now = Now->next)
    {
        Count++;
    }
    return Count;
}


// 연결 리스트의 모든 노드와 머리를 해제
void UnInitList()
{
    while (DeleteNode(head->next)) { ; }
    free(head);
    head = NULL;
}

void main()
{
    int i;
    Node* Now, Temp;

    InitList();

    for (i = 1; i <= 5; i++)
    {
        Temp.value = i;
        AppendNode(&Temp);
    }

    for (Now = head->next; Now; Now = Now->next)
    {
        printf("%d\t", Now->value);
    }
    printf("\n");

    printf("노드 개수 = %d\n", GetListCount());

    for (Now = head->next; Now; Now = Now->next)
    {
        if (Now->value == 3) break;
    }

    if (Now)
    {
        printf("Mid=%d, 앞 노드=%d, 뒷 노드=%d\n", Now->value,
               Now->prev->value, Now->next->value);
    }

    printf("3번 노드 = %d\n", FindNodeByIndex(3)->value);
    UnInitList();
}</pre>
