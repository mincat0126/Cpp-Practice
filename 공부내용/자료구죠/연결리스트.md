# 단순 연결 리스트
**연결 리스트**: 요소들이 메모리 도처에 흩어져서 존재하지만 링크에 의해 논리적으로 연결되어 있어 링크로 요소들을 찾을 수 있는 자료 구죠  
**링크**: 자기 다음의 요소가 누구인지를 기억하고 연결 정보를 저장하는 것
**머리**: 시작점을 기억하는 노드
> 동적 배열과 연결 리스트는 완전히 같은 용도의 자료 구죠로 서로 대체가 가능하지만 구성 원리나 관리 방법 등이 다르다.  
> 배열 요소 하나는 자신이 기억할 데이터값만 가지지만, 연결 리스트 요소인 노드는 데이터외에 연결 상태에 대한 정보인 링크를 추가로 가져야 한다.
> 링크를 하나만 가지는걸 단순 연결 리스트, 두 개의 링크를 가지는걸 이중 연결 리스트라고 한다.
> 노드를 구성하는 데이터와 링크는 타입이 다르기 때문에 노드는 이형 타입의 집합인 구조체로 정의된다.
> 어떤 노드가 연결 리스트의 첫 번째 노드인지는 따로 정해야 한다.
<img width="476" height="137" alt="image" src="https://github.com/user-attachments/assets/59fab78d-7f97-41d7-88c6-413c692a33b6" />
<img width="444" height="96" alt="image" src="https://github.com/user-attachments/assets/804bcdb5-4617-4c22-beb5-6db165d4f51c" />

<pre>struct Node
{
     int value;            // 데이터
     Node *next;           // 링크
};</pre>  

<pre>#include < stdio.h >
#include < windows.h >

// 노드 구조체
struct Node
{
    int value;
    Node* next;
};
Node* head;

// 연결 리스트 초기화 - 머리를 할당한다.
void InitList()
{
    head = (Node*)malloc(sizeof(Node));
    head->next = NULL;
}

// Target 다음에 노드를 삽입한다.
Node* InsertNode(Node* Target, Node* aNode)
{
    Node* New;
    New = (Node*)malloc(sizeof(Node));

    *New = *aNode;
    New->next = Target->next;
    Target->next = New;

    return New;
}

// Target 다음 노드를 삭제한다.
BOOL DeleteNode(Node* Target)
{
    Node* Del;
    Del = Target->next;

    if (Del == NULL)
    {
        return FALSE;
    }

    Target->next = Del->next;
    free(Del);

    return TRUE;
}

// 연결 리스트의 모든 노드와 머리를 해제한다.
void UnInitList()
{
    while (DeleteNode(head)) { ; }

    free(head);
    head = NULL;
}

void main()
{
    int i;
    Node* Now, Temp;

    InitList();

    // 다섯 개의 노드 삽입
    Now = head;
    for (i = 1; i <= 5; i++)
    {
        Temp.value = i;
        Now = InsertNode(Now, &Temp);
    }

    // 두 번째 노드 삭제
    DeleteNode(head->next);

    // 순회하면서 출력
    for (Now = head->next; Now; Now = Now->next)
    {
        printf("%d\t", Now->value);
    }

    printf("\n");

    UnInitList();
}</pre>
