# 배열
**<배열의 장점>**
1. 가장 기본적인 자료 구조이며 단순하여 배우기 쉽다.
2. 구조가 단순하여 정보 자체를 기억하는 메모리 외에 추가로 소모하는 메모리가 전혀 없어 공간 효율이 좋다.
3. 배열의 크기가 커지더라도 검색 속도가 일정하다.

<br><br><br><br><br>

# 동적 배열
**동적 배열**: 실행중에 필요한 크기를 늘렸다 줄였다 할 수 있는 배열
> C언어에선 동적 배열 지원이 없다.

<pre>#include < stdio.h >
#include < windows.h >

#define ELETYPE int
ELETYPE* ar;

unsigned size;
unsigned num;
unsigned growby;

void InitArray(unsigned asize, unsigned agrowby)
{
    size = asize;
    growby = agrowby;
    num = 0;

    ar = (ELETYPE*)malloc(size * sizeof(ELETYPE));
}

void Insert(int idx, ELETYPE value)
{
    unsigned need;
    need = num + 1;

    if (need > size)
    {
        size = need + growby;
        ar = (ELETYPE*)realloc(ar, size * sizeof(ELETYPE));
    }

    memmove(ar + idx + 1, ar + idx, (num - idx) * sizeof(ELETYPE));
    ar[idx] = value;
    num++;
}

void Delete(int idx)
{
    memmove(ar + idx, ar + idx + 1, (num - idx - 1) * sizeof(ELETYPE));
    num--;
}

void Append(ELETYPE value)
{
    Insert(num, value);
}

void UnInitArray()
{
    free(ar);
}

void DumpArray(const char* sMark)
{
    unsigned i;

    printf("%16s => 크기=%02d,개수=%02d : ", sMark, size, num);

    for (i = 0; i < num; i++)
    {
        printf("%2d ", ar[i]);
    }

    printf("\n");
}

void main()
{
    int i;

    InitArray(10, 5); DumpArray("최초");

    for (i = 1; i <= 8; i++) Append(i); DumpArray("8개 추가");

    Insert(3, 10); DumpArray("10 삽입");
    Insert(3, 11); DumpArray("11 삽입");
    Insert(3, 12); DumpArray("12 삽입");
    Delete(7); DumpArray("요소 7 삭제");

    UnInitArray();
}</pre>
