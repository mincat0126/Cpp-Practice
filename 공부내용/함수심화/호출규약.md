# 호출 규약
**호출 규약**: 함수를 호출하는 방식에 대한 일종의 약속     
> 리턴하는 방식은 모두 같다  
> 4바이트 값 리턴은 eax 레지스터를 사용한다.   
> 8바이트 값 리턴은 edx:eax 레지스터 쌍을 사용한다.   
> 8바이트를 초과하는 값 리턴은 임시 영역에 리턴할 값을 넣어둔 후 그 포인터를 eax 리턴한다.

|호출규약|인수 전달|스택 정리|이름 규칙|
|----|----|----|----|
|__cdecl|오른쪽 먼저|호출원|_함수명|
|__stdcall|오른쪽 먼저|함수|_함수명@인수크기|
|__fastcall|	ECX, EDX에 우선 전달. 나머지는 오른쪽 먼저|함수|@함수명@인수크기|
|thiscall|오른쪽 먼저, this 포인터는 ecx 레지스터로 전달된다.|함수|C++ 이름 규칙에 따름|
|__naked|오른쪽 먼저|함수|없음|

<br><br><br>
# 스택
**스택**: 시스템이 사용하는 메모리 공간 호출 규약  
**힙**: 실행중에 동적으로 할당되는 메모리 영역이며, 할당이 발생하면 뒤쪽으로 이동하면서 자유 영역 사용   
**PUSH**: 스택에 값을 넣는 동작  
**POP**: 스택에 저장된 값을 빼내는 동작  
> CPU가 임시적인 정보를 저장할 때 스택을 쓴다.  
> 스택의 현재 위치는 esp 레지스터에 기억된다.  
> push하면 esp가 감소하며 값이 스택으로 들어가고, pop하면 esp가 증가하며 값을 빼낸다.   
> push A는 esp-4, mov [esp],A와 같으며, pop A는 mov A,[esp], esp+=4와 같다.  
> 32비트 시스템의 스택 한칸 크기는 4이지만 시스템에 따라 2나 8이 될 수도 있다.  
> 스택에 들어간 값은 LIFO(Last In First Out)원칙에 따라 가장 늦게 들어간 값이 가장 먼저 나온다.   
> CPU의 범용 레지스터가 많지 않아서 필요한 레지스터가 이미 값을 값을 가지고 있을 땐 스택에 레지스터 값을 잠시 대피해 놓고 사용.  
> 저장된 값을 복구할 때는 push한 반대 순서로 pop해야 한다.  
> esp는 push될 때 감소하고 pop할 때 증가하며 다음 엑세스 할 위치를 가리킨다.

<img width="285" height="172" alt="image" src="https://github.com/user-attachments/assets/1b2f1c06-baed-4a98-8630-42ca635d0170">

<br><br><br>
## 스택 프레임
**스택 프레임**: 스택에 저장되는 함수의 호출 정보  
**접두**: 함수가 실행을 준비하는 과정  
**접미**: 정리 작업을 하는 코드  
> call 명령은 함수가 복귀할 번지를 스택에 푸시한 후 함수의 번지로 점프하는 것

<pre>#include < stdio.h >
int Add(int a, int b)
{
  int c,d,e;
  c=a+b;
  return c;
}

int main()
{
  int result;
  result=Add(1,2);
  printf("%d",result);
}

/*
  push 2
  push 1             인수들을 스택에 푸쉬
  call Add           함수가 복귀할 번지를 푸쉬 후 Add 함수로 점프
  add esp,8          복귀, 함수 호출 전 인수 전달을 위해 푸쉬한 값 삭제 
  result=eax

  push ebp           호출원에서 사용하던 ebp를 푸쉬 후 ebp에 현재 위 대입, ebp를 기준 번지로 사용
  mov ebp,esp
  sub esp,0ch        esp를 12만큼(정수형 변수 3개) 감소시켜 지역변수의 공간 확보, 여기까지가 접두
  mov eax,[ebp+8]    eax에 1 대입
  add eax,[ebp+0ch]  eax의 1 + 2
  mov [ebp-4],eax    c= eax
  mov eax,[ebp-4]    return c
  mov esp,ebp        지역변수를 위해 할당했던 스택 영역 회수, 여기부터 접미 
  pop ebp
  ret                스택에 저장된 복귀 번지를 꺼내 그 번지로 리턴 
/*
</pre>

<img width="276" height="162" alt="image" src="https://github.com/user-attachments/assets/2ff75a3e-716c-4d04-9be7-07e6d0856c8e" />
<br><br><br>

# __stdcall
**__stdcall**: 윈도우즈 API의 기본 호출 규약  
&nbsp;&nbsp;&nbsp;**형태**: 리턴값 __stdcall 함수명(인수들)  
> 함수가 직접 스택을 정리하기 때문에 가변 인수 함수를 지원하지 않는다.  
> 윈도우즈 기본 호출 규약은 __stdcall이지만 가변 인수 함수때문에 wsprintf는 __cdecl을 사용한다.    
> 가변 인수 함수를 __stdcall로 작성하면 컴파일러는 무시하고 __cdecl을 사용한다.  
> 가변 인수 함수를 지원하는 호출 규약은 __cdecl이 유일하다.

<pre>int __stdcall Add(int a, int b)
{
     int c,d,e;
     c=a+b;
     return c;
}

/*
push 2
push 1
call Add
result=eax

push ebp      접미 부분 변경
....
ret 8
*/</pre><br><br><br>

# __fastcall
&nbsp;&nbsp;&nbsp;**형태**: 리턴값 __fastcall 함수명(인수들)  

<pre>mov edx,2
mov ecx,1
call Add
result=eax

push ebp
mov ebp,esp
sub esp,14h
mov [ebp-8],edx             // 첫 번째 인수를 지역변수로
mov [ebp-4],ecx             // 두 번째 인수를 지역변수로
mov eax,[ebp-4]
add eax,[ebp-8]
mov [ebp-0ch],eax           // c는 세 번째 지역변수가 된다.
mov eax,[ebp-0ch]
mov esp,ebp
pop ebp
ret</pre><br><br><br>

# thiscall
> 클래스의 멤버 함수에 대해서만 적용된다.  
> ecx로 객체의 포인터(this)가 전달되며 나머지 규칙은 __stdcall과 동일하다.  
> 가변 인수를 사용하는 멤버 함수는 __cdecl로 작성되며 이때 this는 스택 제일 마지막(첫 번째 인수)에 전달.

<br><br><br>

# __naked
**__naked**: 컴파일러가 접두, 접미를 작성하지 않는 호출 규약
