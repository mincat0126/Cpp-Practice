# 호출 규약
**호출 규약**: 함수를 호출하는 방식에 대한 일종의 약속    

# 스택
**스택**: 시스템이 사용하는 메모리 공간 호출 규약  
**힙**: 실행중에 동적으로 할당되는 메모리 영역이며, 할당이 발생하면 뒤쪽으로 이동하면서 자유 영역 사용   
**PUSH**: 스택에 값을 넣는 동작  
**POP**: 스택에 저장된 값을 빼내는 동작  
> CPU가 임시적인 정보를 저장할 때 스택을 쓴다.  
> 스택의 현재 위치는 esp 레지스터에 기억된다.  
> push하면 esp가 감소하며 값이 스택으로 들어가고, pop하면 esp가 증가하며 값을 빼낸다.   
> push A는 esp-4, mov [esp],A와 같으며, pop A는 mov A,[esp], esp+=4와 같다.  
> 32비트 시스템의 스택 한칸 크기는 4이지만 시스템에 따라 2나 8이 될 수도 있다.  
> 스택에 들어간 값은 LIFO(Last In First Out)원칙에 따라 가장 늦게 들어간 값이 가장 먼저 나온다.   
> CPU의 범용 레지스터가 많지 않아서 필요한 레지스터가 이미 값을 값을 가지고 있을 땐 스택에 레지스터 값을 잠시 대피해 놓고 사용.  
> 저장된 값을 복구할 때는 push한 반대 순서로 pop해야 한다.  
> esp는 push될 때 감소하고 pop할 때 증가하며 다음 엑세스 할 위치를 가리킨다.
<img width="285" height="172" alt="image" src="https://github.com/user-attachments/assets/1b2f1c06-baed-4a98-8630-42ca635d0170" />

## 스택 프레임
**스택 프레임**: 스택에 저장되는 함수의 호출 정보  
**접두**: 함수가 실행을 준비하는 과정  
**접미**: 정리 작업을 하는 코드  
> call 명령은 함수가 복귀할 번지를 스택에 푸시한 후 함수의 번지로 점프하는 것

<pre>#include < stdio.h >
int Add(int a, int b)
{
  int c,d,e;
  c=a+b;
  return c;
}

int main()
{
  int result;
  result=Add(1,2);
  printf("%d",result);
}

/*
  push 2
  push 1             인수들을 스택에 푸쉬
  call Add           함수가 복귀할 번지를 푸쉬 후 Add 함수로 점프
  add esp,8          복귀, 함수 호출 전 인수 전달을 위해 푸쉬한 값 삭제 
  result=eax

  push ebp           호출원에서 사용하던 ebp를 푸쉬 후 ebp에 현재 위 대입, ebp를 기준 번지로 사용
  mov ebp,esp
  sub esp,0ch        esp를 12만큼(정수형 변수 3개) 감소시켜 지역변수의 공간 확보, 여기까지가 접두
  mov eax,[ebp+8]    eax에 1 대입
  add eax,[ebp+0ch]  eax의 1 + 2
  mov [ebp-4],eax    c= eax
  mov eax,[ebp-4]    return c
  mov esp,ebp        지역변수를 위해 할당했던 스택 영역 회수, 여기부터 접미 
  pop ebp
  ret                스택에 저장된 복귀 번지를 꺼내 그 번지로 리턴 
/*
</pre>
<img width="276" height="162" alt="image" src="https://github.com/user-attachments/assets/2ff75a3e-716c-4d04-9be7-07e6d0856c8e" />
