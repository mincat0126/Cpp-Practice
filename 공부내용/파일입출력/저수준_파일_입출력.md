# 파일 핸들
**핸들**: 열려진 파일을 대표하는 값이며 파일을 액세스하기 위한 모든 정보가 저장되어 있는 것  
**_open,_close**: 파일을 열고 닫는 함수  
&nbsp;&nbsp;&nbsp;**형태**: int _open(const char *filename, int oflag [,int pmode] );  
&nbsp;&nbsp;&nbsp;**형태**: int _close(int fd);  
> 저수준 파일 입출력 방법은 운영체제가 파일을 관리하는 방법과 동일하다.  
> 저수준은 파일을 핸들로 관리한다.  
> 저수준 파일 입출력 함수 앞에는 _가 있는데 _로 시작하는 함수는 표준이 아닌 확장이라는 뜻이다.  
> filename 인수로 드라이브와 디렉토리 정보를 포함한 완전 경로나 현재 기준으로 한 상대 경로를 줄 수 있다.    
> oflag 인수에 or 연산자로 여러 개의 플래그를 한꺼번에 지정 가능하다.   
> pmode 인수는 파일의 보안 속성을 정하는데 _O_CREAT 플래그로 파일을 새로 만들때만 적용되고 나머지 파일로 열 땐 생략된다.  
> 생성한 파일을 닫을 때 보안 속성이 적용되는데 이미 파일이 존재하면 pmode인수는 생략된다.  
>  _S_* 매크로 상수들은 sys/stat.h 헤더 파일에 정의되어 있다.  
> 파일 입출력 함수가 끝난 후 _close 함수로 닫는다.  
> _open에서 사용하는 플래그들은 io.h와 fcntl.h 파일에 정의되어 있다.

|플래그|설명|
|----|----|
|_O_BINARY|이진 모드로 열기|
|_O_TEXT|텍스트 모드로 열기|
|_O_CREAT|새로 파일을 만들며 파일이 이미 존재하면 아무것도 안함|
|_O_RDONLY|읽기 전용으로 열기|
|_O_RDWR|읽고 쓰기가 가능하도록 열기|
|_O_WRONLY|쓰기 전용으로 열기|
|_O_TRUNC|파일을 열고 크기를 0으로 만듦._O_CREAT와 함께 사용될 경우 새로 파일을 만든다|
|_O_APPEND|FP를 파일 끝으로 보냄|
|_O_RANDOM|캐시를 임의 접근 방식으로 최적화|
|_O_SEQUENTIAL|캐시를 순차 접근 방식으로 최적화|
|_O_SHORT_LIVED|_O_CREAT 플래그와 함께 사용되며 임시 파일을 만듦|
|_O_TEMPORARY|_O_CREAT 플래그와 함께 사용되며 파일을 닫을 때 삭제한다.|
|_O_EXCL|_O_CREAT 플래그와 함께 사용되며 파일이 이미 존재할 경우 에러를 리턴한다.|

<br><br><br><br><br>
# 저수준 파일 액세스
**_read**: 저수준 파일을 count 바이트만큼 읽어 버퍼에 채운 후 읽은 실제 바이트 수를 리턴하는 함수  
&nbsp;&nbsp;&nbsp;**형태**: int _read(int fd, void *buffer, unsigned int count  
> fd 인수로 파일 핸들을 요구하는데 _open으로 구한 핸들을 전달하면 된다.   
> 파일에서 바이트를 읽은 후 FP는 읽은만큼 뒤로 자동으로 이동한다.  
> 만약 파일 끝이거나 파일 핸들이 무효하다면 -1을 리턴한다.  
> 파일을 텍스트 모드로 열었을 경우 CR/LF 조합은 LF로 변환되어 읽혀지며 Ctrl+Z를 만나면 파일의 끝으로 인식한다.

**_write**: 저수준 파일을 버퍼에 저장된 count 바이트만큼 파일로 출력하는 함수  
&nbsp;&nbsp;&nbsp;**형태**: int _write(int fd, const void *buffer, unsigned int count);  
> 리턴값은 실제로 파일로 출력된 바이트수이다.

<pre>#include < stdio.h >
#include < io.h >
#include < fcntl.h >

void main()
{
    int file;
    char buf[256] = { 0, };
    file = _open("c:\\Test.txt", _O_RDONLY);

    if (file != -1)
    {
        _read(file, buf, 256);
        printf("%s", buf);
        _close(file);
    }
}</pre>

<pre>#include < stdio.h >
#include < windows.h >
#include < io.h >
#include < fcntl.h >
#include  <sys/stat.h >

void main(int argc, char* argv[])
{
    int src, dest;
    int readnum;
    void* buf;

    if (argc < 3)
    {
        printf("복사 원본과 목적 파일 이름을 지정해야 합니다.\n");
        exit(1);
    }   

    src = _open(argv[1], _O_RDONLY | _O_BINARY);

    if (src == -1)
    {
        printf("원본 파일을 열 수 없습니다.\n");
        exit(1);
    }

    dest = _open(argv[2], _O_CREAT | _O_WRONLY | _O_BINARY | _O_TRUNC, _S_IWRITE);
    if (dest == -1)
    {
        printf("목적 파일을 생성할 수 없습니다.\n");
        _close(src);
        exit(1);
    }

    buf = malloc(60000);

    for (;;)
    {
        readnum = _read(src, buf, 60000);
        if (readnum == 0)
        {
            break;
        }
        _write(dest, buf, readnum);
    }

    _close(src);
    _close(dest);
    free(buf);
    printf("%s 파일을 %s로 복사했습니다.\n", argv[1], argv[2]);
}</pre><br><br><br>

**_lseek,_tell**: 저수준 파일 입출력 임의 접근 함수  
&nbsp;&nbsp;&nbsp;**형태**: long _lseek(int fd, long offset, int origin);  
&nbsp;&nbsp;&nbsp;**형태**: long _tell(int fd);
