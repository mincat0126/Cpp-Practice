# 순차 검색 
**검색**: 원하는 자료를 빠르게 찾고, 새로 추가, 삭제되는 자료들도 다음 검색을 위해 어떻게 조직할 것인지까지 포괄하는 종합 자료 관리 알고리즘    
**순차검색**: 테이블의 처음부터 순서대로 읽으면서 원하는 키와 비교하기를 검색에 성공하거나 아니면 테이블 끝에 이를 때까지 반복하는 것  
&nbsp;&nbsp;&nbsp;**형태**:  
void *lsearch(const void *key, void *base, unsigned int *num, unsigned int width, int (__cdecl *compare)(const void *elem1, const void *elem2));  
**프라이머리 키**: 레코드간에 중복되지 않은 유일한 키    
> 인수로 키, 테이블 선두 번지, 개수, 크기, 비교 함수에 대한 함수 포인터를 받는다.  
> lsearch 함수는 테이블의 모든 요소에 대해 비교를 수행한 후 검색된 포인터를 리턴하되 발견되지 않으면 NULL을 리턴한다.  
> search.h에 내장되어 있다.

<pre>#include < stdio.h >
#include < search.h >

int LinearSearch(int* ar, unsigned num, int key)
{
    unsigned i;

    for (i = 0; i < num; i++)
    {
        if (ar[i] == key)
        {
            return i;
        }
    }
    return -1;
}

void main()
{
    int ar[] = { 23,47,19,63,57,26,75,73,82,89,47,11 };
    unsigned num;
    int key, idx;

    num = sizeof(ar) / sizeof(ar[0]);
    key = 75;
    idx = LinearSearch(ar, num, key);

    if (idx == -1)
    {
        puts("찾는 값이 없습니다.");
    }
    else
    {
        printf("찾는 값은 %d번째에 있습니다.\n", idx);
    }
}</pre>

<pre>#include < stdio.h >
#include < search.h >

int compare(const void* elem1, const void* elem2)
{
    return (*(int*)elem1 != *(int*)elem2);
}

void main()
{
    int ar[] = { 23,47,19,63,57,26,75,73,82,89,47,11 };
    unsigned num;
    int key;
    int* ptr;

    num = sizeof(ar) / sizeof(ar[0]);
    key = 75;
    ptr = (int*)_lsearch(&key, ar, &num, sizeof(int), compare);

    if (ptr == NULL)
    {
        puts("찾는 값이 없습니다.");
    }
    else
    {
        printf("찾는 값은 %d번째에 있습니다.\n", ptr - ar);
    }
}</pre><br><br><br><br><br>

# 이분 검색
**이분 검색**: 구간의 중간값과 키값의 대소를 구분하여 테이블을 절반씩 나눠 가며 비교하는 방법  
&nbsp;&nbsp;&nbsp;**형태**:  
void *bsearch( const void *key, const void *base, size_t num, size_t width, int ( __cdecl *compare ) ( const void *elem1, const void *elem2 ) );    
> 이분 검색을 하려면 테이블의 모든 자료가 오름차순으로 되어 있어야 한다.  
> compare 함수는 사용자 지정 비교 함수인데, 두 값을 비교해보고 첫 번째 인수가 더 작으면 음수, 같으면 0, 더 크면 양수를 리턴해야 한다.  

<pre>#include < stdio.h >

int BinarySearch(int* ar, unsigned num, int key)
{
    unsigned Upper, Lower, Mid;
    Lower = 0;
    Upper = num - 1;

    for (;;)
    {
        Mid = (Upper + Lower) / 2;

        if (ar[Mid] == key) return Mid;

        if (ar[Mid] > key)
        {
            Upper = Mid - 1;
        }
        else
        {
            Lower = Mid + 1;
        }

        if (Upper <= Lower)
        {
            return -1;
        }
    }
}

void main()
{
    int ar[] = { 2,6,13,19,21,21,23,29,35,48,62,89,90,95,99,102,109,208,629 };
    unsigned num;
    int key, idx;

    num = sizeof(ar) / sizeof(ar[0]);
    key = 29;
    idx = BinarySearch(ar, num, key);

    if (idx == -1)
    {
        puts("찾는 값이 없습니다.");
    }
    else
    {
        printf("찾는 값은 %d번째에 있습니다.\n", idx);
    }
}</pre>

<pre>#include < stdio.h >
#include < search.h >

int compare(const void* elem1, const void* elem2)
{
    return (*(int*)elem1 - *(int*)elem2);
}

void main()
{
    int ar[] = { 2,6,13,19,21,21,23,29,35,48,62,89,90,95,99,102,109,208,629 };
    unsigned num;
    int key;
    int* ptr;

    num = sizeof(ar) / sizeof(ar[0]);
    key = 29;
    ptr = (int*)bsearch(&key, ar, num, sizeof(int), compare);

    if (ptr == NULL)
    {
        puts("찾는 값이 없습니다.");
    }
    else
    {
        printf("찾는 값은 %d번째에 있습니다.\n", ptr - ar);
    }
}</pre><br><br><br><br>

# 해시
**해시**: 자료를 입력할 때부터 검색하기 쉬운 위치에 삽입하는 방법   
**해시 테이블**: 자료가 저장되는 전체 저장소     
**슬롯**: 버킷에 데이터가 저장되는 단위     
**해시 함수**: 자료가 새로 입력될 때 어떤 버킷에 자료를 넣을지를 결정하는 함수     
**충돌**: 버킷이 이미 점령되어 값을 추가할 수 없는 상황     
> 해시 테이블은 여러개의 버킷으로 나뉘어져 있다.  
> 해시값은 복원 가능하지 않아도 상관없다.   

<img width="476" height="121" alt="image" src="https://github.com/user-attachments/assets/e007d44d-ee09-4fa6-a5a5-3848236f97fd" />
<img width="429" height="133" alt="image" src="https://github.com/user-attachments/assets/e610aa28-d1a0-4e70-808f-5eaaf3d9c5ea" />

<pre>#include < stdio.h >
#include < windows.h >

#define BK 10
#define SL 1

int hashtable[BK][SL];

int hash(int key)
{
    return key % 10;
}

void AddKey(int key)
{
    int bucket;
    bucket = hash(key);

    if (hashtable[bucket][0] == 0)
    {
        hashtable[bucket][0] = key;
    }
}

BOOL FindKey(int key)
{
    int bucket;
    bucket = hash(key);
    return (hashtable[bucket][0] == key);
}

void main()
{
    int i, key;

    memset(hashtable, 0, sizeof(hashtable));

    for (i = 0; i < 5; i++)
    {
        printf("%d번째 값을 입력하세요 : ", i + 1); scanf("%d", &key);
        AddKey(key);
    }

    printf("검색할 키를 입력하세요 : "); scanf("%d", &key);

    if (FindKey(key))
    {
        puts("검색되었습니다.");
    }
    else
    {
        puts("입력하신 값은 없습니다..");
    }
}</pre>

<pre>#include < stdio.h > //다중 슬롯 방법
#include < windows.h >

#define BK 10
#define SL 3
int hashtable[BK][SL];

int hash(int key)
{
    return key % 10;
}

void AddKey(int key)
{
    int i, bucket;
    bucket = hash(key);

    for (i = 0; i < SL; i++)
    {
        if (hashtable[bucket][i] == 0)
        {
            hashtable[bucket][i] = key;
            break;
        }
    }
}

BOOL FindKey(int key)
{
    int i, bucket;
    bucket = hash(key);

    for (i = 0; i < SL; i++)
    {
        if (hashtable[bucket][i] == key)
        {
            return TRUE;
        }
    }

    return FALSE;
}

//====================== main은 동일하므로 생략 ======================</pre><br><br><br>

**선형 탐색법**: 충돌이 발생할 경우 이 데이터를 버리지 않고 다른 버킷에라도 대신 집어 넣는 방법  
> 대체 버킷을 찾는 가장 간단한 방법은 바로 옆칸에 적어 놓는 것이다.

<pre>#include < stdio.h >
#include < windows.h >

#define BK 10
#define SL 1
int hashtable[BK][SL];

int hash(int key)
{
    return key % 10;
}

void AddKey(int key)
{
    int bucket;
    bucket = hash(key);

    while (hashtable[bucket][0] != 0)
    {
        bucket = bucket + 1 % BK;
    }
    hashtable[bucket][0] = key;
}

BOOL FindKey(int key)
{
    int bucket;

    bucket = hash(key);

    while (hashtable[bucket][0] != 0)
    {
        if (hashtable[bucket][0] == key) return TRUE;
        bucket = bucket + 1 % BK;
    }
    return FALSE;
}
//====================== main은 동일하므로 생략 ======================</pre>
