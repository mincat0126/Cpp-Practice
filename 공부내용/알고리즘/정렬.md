# 정렬
**정렬**: 임의의 자료 집합을 일정한 기준에 따라 나열하는 것  
**오름차순 정렬**: 크기가 작은 것을 먼저 나열하는 것  
**내림차순 정렬**: 크기가 큰 것을 먼저 나열하는 것   
> 문자열 형태로 된 수치나 코드값 등은 자료의 구조에 따라 대소를 판별하는 방법이 달라진다.  
> 정렬 대상은 보통 레코드라고 불리는 구조체이다.  
> 구조체의 멤버 중에 정렬의 기준이 되는 멤버를 키(Key)라고 한다.   

<br><br><br><br><br>
# 버블 정렬 
**버블 정렬**: 레코드의 선두부터 인접 요소를 비교하여 큰 값을 뒤로 보내는 정렬   

<pre>> #include < stdio.h >
> #include < string.h >

#define SWAP(a,b) { int t;t=a;a=b;b=t; }

void BubbleSort(char *ar, int num)
{
     int i,j;

     for (i=0;i<num-1;i++) {
          for (j=1;j<num-i;j++) {
              if (ar[j-1] > ar[j]) {
                   SWAP(ar[j-1],ar[j]);
              }
          }
     }
}

void main()
{
     char str[]="winapi";
     
     printf("정렬 전의 문자열 : %s\n",str);
     BubbleSort(str,strlen(str));
     printf("정렬된 문자열 : %s\n",str);
}</pre><br><br><br><br><br>

# 선택 정렬
**선택 정렬**: 최소값을 찾아 앞쪽으로 이동하기를 배열 크기만큼 반복하는 정렬 방법   
> 선택 정렬은 작은 값을 선택하기 위해 비교를 여러 번 하지만 교환 회수가 작은 것이 장점이다.  

<pre>#include < stdio.h >
#include < string.h >

#define SWAP(a,b) { int t;t=a;a=b;b=t; }

void SelectionSort(char* ar, int num)
{
    int minidx;
    int i, j;

    // 배열 전체 순회.
    for (i = 0; i < num - 1; i++)
    {
        // i이후의 최소값을 찾는다.
        for (minidx = i, j = i + 1; j < num; j++)
        {
            if (ar[minidx] > ar[j])
            {
                minidx = j;
            }
        }
        // 최소값을 현재항과 교환.
        if (minidx != i)
        {
            SWAP(ar[minidx], ar[i]);
        }
    }
}

void main()
{
    char str[] = "winapi";

    printf("정렬 전의 문자열 : %s\n", str);
    SelectionSort(str, strlen(str));
    printf("정렬된 문자열 : %s\n", str);
}</pre>
